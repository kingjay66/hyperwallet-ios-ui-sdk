//
// Copyright 2018 - Present Hyperwallet
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of this software
// and associated documentation files (the "Software"), to deal in the Software without restriction,
// including without limitation the rights to use, copy, modify, merge, publish, distribute,
// sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all copies or
// substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING
// BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

import Foundation

public protocol Tracking {
    func trackEvent(_ event: String, with params: [String: Any])
}

public class FPTITracker: NSObject, Tracking {
    private static var instance: Tracking?

    /// Returns the previously initialized instance of the Hyperwallet UI SDK interface object
    public static var shared: Tracking {
        if instance == nil {
            instance = FPTITracker()
        }
        return instance!
    }
    private var timerForFPTI: DispatchSourceTimer?
    private let sessionId = UUID().uuidString
    /// Tracker Options defining some key parameters for tracker to operate.
    var options = TrackerOptions()
    /// Dispatch Queue to send all tracker Events.
    let eventDispatchQueue: DispatchQueue

    /// Get a shared reference to the Local Disk Cache. Internally, this is using
    /// Core Data to cache the events
    var cacheController: FPTIEventsCache

    /// Initializer for FPTI Tracker. Typically within an application, you want to have only one
    /// instance of the tracker. Upon initialization, this will also keep a check on existing events
    /// that are pending to be send to the server.
    override private init() {
        eventDispatchQueue = DispatchQueue(label: "com.hyperwallet.fpti", qos: .background)
        options = TrackerOptions()
        self.cacheController = FPTIEventCacheController.shared
        super.init()
    }

    public func trackEvent(_ event: String, with params: [String: Any]) {
        let eventParams = enrichLocalUserEvent(eventParams: params)
        eventDispatchQueue.async {
            self.cacheController.saveEvent(eventParams: eventParams,
                                           forSession: (eventParams[FPTITag.sessionId] as? String)!)
            self.flushIfQueueFull()
            self.startFlushTimer()
        }
    }

    private func enrichLocalUserEvent(eventParams: [String: Any]) -> [String: Any] {
        var eventParamsMutable: [String: Any] = eventParams
        eventParamsMutable[FPTITag.sessionId] = sessionId
        let fptiAutoGeneratedPayload = FPTITagsPayloadGenerator()
        let autoGeneratedParams = fptiAutoGeneratedPayload.buildEvent()
        autoGeneratedParams.forEach { paramKey, paramValue in
            eventParamsMutable[paramKey] = paramValue
        }
        return eventParamsMutable
    }

    /**
     Starts a Tracker Timer for Firing events at regular events.
     If this is the first time a timer is initialized , then create a new timer event.
     Or work with the timer
     */
    private func startFlushTimer() {
        // Initialize a timer
        initTimerWithTimeInterval(timeInterval: options.autoFlushTimerInterval)
    }

    private func flushIfQueueFull() {
        /// Once the event is saved in the database, do check if we have reached the max number of
        /// events that can be handled by the batch. try sending it over the network if that number
        /// has reached the @MAX_BATCH_SIZE
        if cacheController.getEventCount() >= options.maxBatchSize {
            print("Maximum batch size reached. Flusing data now. ")
            /// Send the event to FPIT with a completion handler after flushing Data.
            flushData()
        }
    }

    /** Flushes any saved events in the database to the server. This method also batches events while
     sending events over the network and doesn't send everything at once to avoid any huge payloads.

     Although the large events paylaod scenario is very less probable with our auto flush modes and
     batch event count monitoring, this takes care of everything independently.
     */
    @objc
    func flushData() {
        // Get all events in the database and make a batch network call.
        // Queue operations to get all sessions first and send those sessions once we have them
        DispatchQueue.global(qos: .background).async {
            print("Flushing Data from local cache. ")
            do {
                let events = try self.cacheController.getAllEvents()
                //TODO make an api call to flush events to lighthouse
                // TODO in success of API call set timer to nil and purge sent events
                if let eventKeys = events?.eventKeys {
                    self.cacheController.deleteSentEvents(eventKeys: eventKeys)
                }
                self.timerForFPTI = nil
                print("Flush Complete")
            } catch {
                print("Error fetching events")
            }
        }
    }

    /// Initializes the timer associateSed with the FPTI Tracker. This timer will fire events to the
    /// Batch API at regular time intervals and send any data it has to the server.
    @objc private func initTimerWithTimeInterval(timeInterval: TimeInterval) {
        timerForFPTI = DispatchSource.makeTimerSource(queue: eventDispatchQueue)
        guard let timerToFire = timerForFPTI else {
            return
        }
        timerToFire.setEventHandler {
            print("Triggering Auto Flush Timer.")
            self.flushData()
        }
        timerToFire.schedule(deadline: DispatchTime.now() + DispatchTimeInterval.seconds(Int(timeInterval)),
                             repeating: timeInterval)
        timerToFire.resume()
    }
}
